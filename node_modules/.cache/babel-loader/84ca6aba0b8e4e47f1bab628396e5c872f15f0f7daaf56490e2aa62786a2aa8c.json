{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nexport default {\n  name: 'App',\n  data() {\n    return {\n      player1: {\n        x: 100,\n        y: 100,\n        size: 50,\n        color: 'blue',\n        speed: 10,\n        isShooting: false,\n        bullets: [],\n        shootingCooldown: 0,\n        score: 0\n      },\n      player2: {\n        x: 200,\n        y: 300,\n        size: 50,\n        color: 'red',\n        speed: 5,\n        armor: 3,\n        score: 0\n      },\n      items: [],\n      itemSize: 20,\n      itemTypes: ['speed', 'armor'],\n      level: 1,\n      maze: [{\n        x: 50,\n        y: 50,\n        width: 200,\n        height: 20\n      },\n      // Example obstacle\n      {\n        x: 100,\n        y: 100,\n        width: 20,\n        height: 200\n      }, {\n        x: 300,\n        y: 150,\n        width: 20,\n        height: 300\n      }, {\n        x: 500,\n        y: 100,\n        width: 300,\n        height: 20\n      }, {\n        x: 200,\n        y: 400,\n        width: 20,\n        height: 200\n      }],\n      timer: 120000,\n      // 2 minutes in milliseconds\n      intervalId: null,\n      frameRate: 1000 / 60\n    };\n  },\n  computed: {\n    timeLeft() {\n      return Math.max(0, Math.floor(this.timer / 1000));\n    }\n  },\n  mounted() {\n    this.initCanvas();\n    this.startGame();\n    this.generateItems();\n    this.startTimer();\n  },\n  methods: {\n    initCanvas() {\n      this.canvas = this.$refs.gameCanvas;\n      this.context = this.canvas.getContext('2d');\n    },\n    startGame() {\n      this.update();\n      window.addEventListener('keydown', this.handleKeyDown);\n      window.addEventListener('keyup', this.handleKeyUp);\n    },\n    handleKeyDown(event) {\n      switch (event.key) {\n        case 'w':\n          this.player1.y -= this.player1.speed;\n          break;\n        case 's':\n          this.player1.y += this.player1.speed;\n          break;\n        case 'a':\n          this.player1.x -= this.player1.speed;\n          break;\n        case 'd':\n          this.player1.x += this.player1.speed;\n          break;\n        case 'f':\n          this.player1.isShooting = true;\n          break;\n        case 'ArrowUp':\n          this.player2.y -= this.player2.speed;\n          break;\n        case 'ArrowDown':\n          this.player2.y += this.player2.speed;\n          break;\n        case 'ArrowLeft':\n          this.player2.x -= this.player2.speed;\n          break;\n        case 'ArrowRight':\n          this.player2.x += this.player2.speed;\n          break;\n      }\n      this.checkBoundaries(this.player1);\n      this.checkBoundaries(this.player2);\n    },\n    handleKeyUp(event) {\n      if (event.key === 'f') {\n        this.player1.isShooting = false;\n      }\n    },\n    update() {\n      this.clearCanvas();\n      this.moveBullets();\n      this.drawMaze();\n      this.drawItems();\n      this.drawPlayer(this.player1);\n      this.drawPlayer(this.player2);\n      this.checkCollisions();\n      this.handleShooting();\n      this.removeExpiredItems();\n      this.updateScore();\n      this.checkLevelUp();\n      if (this.timer <= 0) {\n        this.endGame();\n      }\n      requestAnimationFrame(this.update);\n    },\n    drawPlayer(player) {\n      this.context.fillStyle = player.color;\n      this.context.fillRect(player.x, player.y, player.size, player.size);\n    },\n    moveBullets() {\n      this.player1.bullets.forEach(bullet => {\n        bullet.x += bullet.dx;\n        bullet.y += bullet.dy;\n      });\n      this.player1.bullets = this.player1.bullets.filter(bullet => {\n        return bullet.x >= 0 && bullet.x <= this.canvas.width && bullet.y >= 0 && bullet.y <= this.canvas.height;\n      });\n    },\n    handleShooting() {\n      if (this.player1.isShooting && this.player1.shootingCooldown <= 0) {\n        this.player1.bullets.push({\n          x: this.player1.x + this.player1.size / 2,\n          y: this.player1.y,\n          dx: 0,\n          dy: -10\n        });\n        this.player1.shootingCooldown = 30; // Cooldown frame count\n      }\n      this.player1.shootingCooldown = Math.max(0, this.player1.shootingCooldown - 1);\n      this.player1.bullets.forEach(bullet => {\n        this.context.fillStyle = 'black';\n        this.context.fillRect(bullet.x, bullet.y, 5, 10);\n      });\n    },\n    checkCollisions() {\n      this.player1.bullets.forEach(bullet => {\n        if (this.isCollision(bullet, this.player2)) {\n          this.player2.armor -= 1;\n          this.player1.score += 10;\n          bullet.isHit = true;\n        }\n      });\n      this.player1.bullets = this.player1.bullets.filter(bullet => !bullet.isHit);\n      this.items.forEach(item => {\n        if (this.isCollision(item, this.player1)) {\n          if (item.type === 'speed') {\n            this.player1.speed += 10;\n          } else if (item.type === 'armor') {\n            this.player2.armor += 1;\n          }\n          item.isCollected = true;\n        }\n      });\n      this.items = this.items.filter(item => !item.isCollected);\n\n      // Check for collisions with maze\n      this.checkMazeCollision(this.player1);\n      this.checkMazeCollision(this.player2);\n    },\n    checkBoundaries(player) {\n      if (player.x < 0) player.x = 0;\n      if (player.y < 0) player.y = 0;\n      if (player.x + player.size > this.canvas.width) player.x = this.canvas.width - player.size;\n      if (player.y + player.size > this.canvas.height) player.y = this.canvas.height - player.size;\n    },\n    checkMazeCollision(player) {\n      this.maze.forEach(obstacle => {\n        if (this.isCollision(player, obstacle)) {\n          // Handle collision with maze\n          player.x = Math.max(obstacle.x + obstacle.width, player.x);\n          player.y = Math.max(obstacle.y + obstacle.height, player.y);\n        }\n      });\n    },\n    isCollision(obj1, obj2) {\n      return obj1.x < obj2.x + obj2.width && obj1.x + obj1.size > obj2.x && obj1.y < obj2.y + obj2.height && obj1.y + obj1.size > obj2.y;\n    },\n    generateItems() {\n      for (let i = 0; i < 10; i++) {\n        this.items.push({\n          x: Math.random() * (this.canvas.width - this.itemSize),\n          y: Math.random() * (this.canvas.height - this.itemSize),\n          size: this.itemSize,\n          type: this.itemTypes[Math.floor(Math.random() * this.itemTypes.length)]\n        });\n      }\n    },\n    drawItems() {\n      this.items.forEach(item => {\n        this.context.fillStyle = item.type === 'speed' ? 'green' : 'purple';\n        this.context.fillRect(item.x, item.y, item.size, item.size);\n      });\n    },\n    drawMaze() {\n      this.context.fillStyle = 'grey';\n      this.maze.forEach(obstacle => {\n        this.context.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);\n      });\n    },\n    removeExpiredItems() {\n      // Cleanup items and other necessary operations can be done here\n    },\n    clearCanvas() {\n      this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    },\n    updateScore() {\n      // Update the score or other game metrics if needed\n    },\n    checkLevelUp() {\n      // Implement level-up logic here, e.g., increase difficulty, add new obstacles, etc.\n      if (this.player1.score >= 100) {\n        this.level++;\n        this.player1.score = 0; // Reset score or keep it for the next level\n        // Add new obstacles or modify the maze for the next level\n      }\n    },\n    startTimer() {\n      this.intervalId = setInterval(() => {\n        this.timer -= this.frameRate;\n        if (this.timer <= 0) {\n          this.timer = 0;\n        }\n      }, this.frameRate);\n    },\n    endGame() {\n      clearInterval(this.intervalId);\n      window.removeEventListener('keydown', this.handleKeyDown);\n      window.removeEventListener('keyup', this.handleKeyUp);\n      alert('Game Over!');\n    }\n  },\n  beforeDestroy() {\n    window.removeEventListener('keydown', this.handleKeyDown);\n    window.removeEventListener('keyup', this.handleKeyUp);\n    clearInterval(this.intervalId);\n  }\n};","map":{"version":3,"names":["name","data","player1","x","y","size","color","speed","isShooting","bullets","shootingCooldown","score","player2","armor","items","itemSize","itemTypes","level","maze","width","height","timer","intervalId","frameRate","computed","timeLeft","Math","max","floor","mounted","initCanvas","startGame","generateItems","startTimer","methods","canvas","$refs","gameCanvas","context","getContext","update","window","addEventListener","handleKeyDown","handleKeyUp","event","key","checkBoundaries","clearCanvas","moveBullets","drawMaze","drawItems","drawPlayer","checkCollisions","handleShooting","removeExpiredItems","updateScore","checkLevelUp","endGame","requestAnimationFrame","player","fillStyle","fillRect","forEach","bullet","dx","dy","filter","push","isCollision","isHit","item","type","isCollected","checkMazeCollision","obstacle","obj1","obj2","i","random","length","clearRect","setInterval","clearInterval","removeEventListener","alert","beforeDestroy"],"sources":["src/views/Game.vue"],"sourcesContent":["<template>\n  <div id=\"app\">\n    <canvas ref=\"gameCanvas\" width=\"800\" height=\"600\"></canvas>\n    <div class=\"scoreboard\">\n      <div>Player 1 Score: {{ player1.score }}</div>\n      <div>Player 2 Score: {{ player2.score }}</div>\n      <div>Level: {{ level }}</div>\n      <div>Time Left: {{ timeLeft }}s</div>\n      <div>Player 1 Speed: {{ player1.speed }}</div>\n      <div>Player 2 Armor: {{ player2.armor }}</div>\n    </div>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: 'App',\n  data() {\n    return {\n      player1: {\n        x: 100,\n        y: 100,\n        size: 50,\n        color: 'blue',\n        speed: 10,\n        isShooting: false,\n        bullets: [],\n        shootingCooldown: 0,\n        score: 0\n      },\n      player2: {\n        x: 200,\n        y: 300,\n        size: 50,\n        color: 'red',\n        speed: 5,\n        armor: 3,\n        score: 0\n      },\n      items: [],\n      itemSize: 20,\n      itemTypes: ['speed', 'armor'],\n      level: 1,\n      maze: [\n        {x: 50, y: 50, width: 200, height: 20}, // Example obstacle\n        {x: 100, y: 100, width: 20, height: 200},\n        {x: 300, y: 150, width: 20, height: 300},\n        {x: 500, y: 100, width: 300, height: 20},\n        {x: 200, y: 400, width: 20, height: 200}\n      ],\n      timer: 120000, // 2 minutes in milliseconds\n      intervalId: null,\n      frameRate: 1000 / 60\n    };\n  },\n  computed: {\n    timeLeft() {\n      return Math.max(0, Math.floor(this.timer / 1000));\n    }\n  },\n  mounted() {\n    this.initCanvas();\n    this.startGame();\n    this.generateItems();\n    this.startTimer();\n  },\n  methods: {\n    initCanvas() {\n      this.canvas = this.$refs.gameCanvas;\n      this.context = this.canvas.getContext('2d');\n    },\n    startGame() {\n      this.update();\n      window.addEventListener('keydown', this.handleKeyDown);\n      window.addEventListener('keyup', this.handleKeyUp);\n    },\n    handleKeyDown(event) {\n      switch (event.key) {\n        case 'w':\n          this.player1.y -= this.player1.speed;\n          break;\n        case 's':\n          this.player1.y += this.player1.speed;\n          break;\n        case 'a':\n          this.player1.x -= this.player1.speed;\n          break;\n        case 'd':\n          this.player1.x += this.player1.speed;\n          break;\n        case 'f':\n          this.player1.isShooting = true;\n          break;\n        case 'ArrowUp':\n          this.player2.y -= this.player2.speed;\n          break;\n        case 'ArrowDown':\n          this.player2.y += this.player2.speed;\n          break;\n        case 'ArrowLeft':\n          this.player2.x -= this.player2.speed;\n          break;\n        case 'ArrowRight':\n          this.player2.x += this.player2.speed;\n          break;\n      }\n      this.checkBoundaries(this.player1);\n      this.checkBoundaries(this.player2);\n    },\n    handleKeyUp(event) {\n      if (event.key === 'f') {\n        this.player1.isShooting = false;\n      }\n    },\n    update() {\n      this.clearCanvas();\n      this.moveBullets();\n      this.drawMaze();\n      this.drawItems();\n      this.drawPlayer(this.player1);\n      this.drawPlayer(this.player2);\n      this.checkCollisions();\n      this.handleShooting();\n      this.removeExpiredItems();\n      this.updateScore();\n      this.checkLevelUp();\n      if (this.timer <= 0) {\n        this.endGame();\n      }\n      requestAnimationFrame(this.update);\n    },\n    drawPlayer(player) {\n      this.context.fillStyle = player.color;\n      this.context.fillRect(player.x, player.y, player.size, player.size);\n    },\n    moveBullets() {\n      this.player1.bullets.forEach(bullet => {\n        bullet.x += bullet.dx;\n        bullet.y += bullet.dy;\n      });\n      this.player1.bullets = this.player1.bullets.filter(bullet => {\n        return bullet.x >= 0 && bullet.x <= this.canvas.width &&\n            bullet.y >= 0 && bullet.y <= this.canvas.height;\n      });\n    },\n    handleShooting() {\n      if (this.player1.isShooting && this.player1.shootingCooldown <= 0) {\n        this.player1.bullets.push({\n          x: this.player1.x + this.player1.size / 2,\n          y: this.player1.y,\n          dx: 0,\n          dy: -10\n        });\n        this.player1.shootingCooldown = 30; // Cooldown frame count\n      }\n      this.player1.shootingCooldown = Math.max(0, this.player1.shootingCooldown - 1);\n      this.player1.bullets.forEach(bullet => {\n        this.context.fillStyle = 'black';\n        this.context.fillRect(bullet.x, bullet.y, 5, 10);\n      });\n    },\n    checkCollisions() {\n      this.player1.bullets.forEach(bullet => {\n        if (this.isCollision(bullet, this.player2)) {\n          this.player2.armor -= 1;\n          this.player1.score += 10;\n          bullet.isHit = true;\n        }\n      });\n      this.player1.bullets = this.player1.bullets.filter(bullet => !bullet.isHit);\n\n      this.items.forEach(item => {\n        if (this.isCollision(item, this.player1)) {\n          if (item.type === 'speed') {\n            this.player1.speed += 10;\n          } else if (item.type === 'armor') {\n            this.player2.armor += 1;\n          }\n          item.isCollected = true;\n        }\n      });\n      this.items = this.items.filter(item => !item.isCollected);\n\n      // Check for collisions with maze\n      this.checkMazeCollision(this.player1);\n      this.checkMazeCollision(this.player2);\n    },\n    checkBoundaries(player) {\n      if (player.x < 0) player.x = 0;\n      if (player.y < 0) player.y = 0;\n      if (player.x + player.size > this.canvas.width) player.x = this.canvas.width - player.size;\n      if (player.y + player.size > this.canvas.height) player.y = this.canvas.height - player.size;\n    },\n    checkMazeCollision(player) {\n      this.maze.forEach(obstacle => {\n        if (this.isCollision(player, obstacle)) {\n          // Handle collision with maze\n          player.x = Math.max(obstacle.x + obstacle.width, player.x);\n          player.y = Math.max(obstacle.y + obstacle.height, player.y);\n        }\n      });\n    },\n    isCollision(obj1, obj2) {\n      return obj1.x < obj2.x + obj2.width &&\n          obj1.x + obj1.size > obj2.x &&\n          obj1.y < obj2.y + obj2.height &&\n          obj1.y + obj1.size > obj2.y;\n    },\n    generateItems() {\n      for (let i = 0; i < 10; i++) {\n        this.items.push({\n          x: Math.random() * (this.canvas.width - this.itemSize),\n          y: Math.random() * (this.canvas.height - this.itemSize),\n          size: this.itemSize,\n          type: this.itemTypes[Math.floor(Math.random() * this.itemTypes.length)]\n        });\n      }\n    },\n    drawItems() {\n      this.items.forEach(item => {\n        this.context.fillStyle = item.type === 'speed' ? 'green' : 'purple';\n        this.context.fillRect(item.x, item.y, item.size, item.size);\n      });\n    },\n    drawMaze() {\n      this.context.fillStyle = 'grey';\n      this.maze.forEach(obstacle => {\n        this.context.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);\n      });\n    },\n    removeExpiredItems() {\n      // Cleanup items and other necessary operations can be done here\n    },\n    clearCanvas() {\n      this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    },\n    updateScore() {\n      // Update the score or other game metrics if needed\n    },\n    checkLevelUp() {\n      // Implement level-up logic here, e.g., increase difficulty, add new obstacles, etc.\n      if (this.player1.score >= 100) {\n        this.level++;\n        this.player1.score = 0; // Reset score or keep it for the next level\n        // Add new obstacles or modify the maze for the next level\n      }\n    },\n    startTimer() {\n      this.intervalId = setInterval(() => {\n        this.timer -= this.frameRate;\n        if (this.timer <= 0) {\n          this.timer = 0;\n        }\n      }, this.frameRate);\n    },\n    endGame() {\n      clearInterval(this.intervalId);\n      window.removeEventListener('keydown', this.handleKeyDown);\n      window.removeEventListener('keyup', this.handleKeyUp);\n      alert('Game Over!');\n    }\n  },\n  beforeDestroy() {\n    window.removeEventListener('keydown', this.handleKeyDown);\n    window.removeEventListener('keyup', this.handleKeyUp);\n    clearInterval(this.intervalId);\n  }\n};\n</script>\n\n<style>\ncanvas {\n  border: 1px solid black;\n}\n\n.scoreboard {\n  position: absolute;\n  top: 10px;\n  left: 10px;\n  font-size: 20px;\n  color: #333;\n  background: rgba(255, 255, 255, 0.7);\n  padding: 10px;\n  border-radius: 5px;\n}\n</style>\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}